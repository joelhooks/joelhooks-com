{"data":{"site":{"siteMetadata":{"title":"The blog of Joel Hooks","description":"This is where I post my things.","author":"Joel Hooks","keywords":["Video Blogger"]}},"mdx":{"frontmatter":{"title":"Using Custom Jasmine Matchers to Make Unit Tests More Readable","date":"Invalid date","banner":null,"slug":null,"categories":null,"keywords":null},"code":{"body":"function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nreturn ((_ref) => {\n  let {\n    components\n  } = _ref,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return React.createElement(MDXTag, {\n    name: \"wrapper\",\n    components: components\n  }, React.createElement(MDXTag, {\n    name: \"p\",\n    components: components\n  }, React.createElement(MDXTag, {\n    name: \"img\",\n    components: components,\n    parentName: \"p\",\n    props: {\n      \"src\": \"/images/clean_and_dry.jpg\",\n      \"alt\": \"Clean and Dry\"\n    }\n  })), React.createElement(MDXTag, {\n    name: \"p\",\n    components: components\n  }, React.createElement(MDXTag, {\n    name: \"a\",\n    components: components,\n    parentName: \"p\",\n    props: {\n      \"href\": \"http://www.flickr.com/photos/29601732@N06/3969905051/\"\n    }\n  }, `Image from purplemattfish`)), React.createElement(MDXTag, {\n    name: \"p\",\n    components: components\n  }, `I'm a stickler for the \"single assertion per test\" guideline. One of the pillars of good unit tests is readability. Multiple asserts undermine this principle and make tests that are more difficult to read, understand, and maintain. A clean solution to this problem is to use custom Jasmine matchers in place of multiple assertions.`), React.createElement(MDXTag, {\n    name: \"h2\",\n    components: components\n  }, `Keep it DRY, Even (Especially?) in Tests`), React.createElement(MDXTag, {\n    name: \"p\",\n    components: components\n  }, `Consider the following:`), React.createElement(MDXTag, {\n    name: \"p\",\n    components: components\n  }, `In our app, we recieve a \"split date\" object from our service. It returns a value in the `, React.createElement(\"code\", {\n    className: \"language-text\"\n  }, '{', \"year: 2012, month: 11, day: 17\", '}'), ` format. We have some functionality that will convert the format back and for to a JavaScript `, React.createElement(\"code\", {\n    className: \"language-text\"\n  }, \"Date\"), `.`), React.createElement(MDXTag, {\n    name: \"p\",\n    components: components\n  }, `This seems straight forward enough, but as it turns out we need to go the other direction as well:`), React.createElement(MDXTag, {\n    name: \"p\",\n    components: components\n  }, `This is bothersome. We have two stacks of `, React.createElement(\"code\", {\n    className: \"language-text\"\n  }, \"expect\"), ` calls that are very similar, but different enough to require a bit more than a helper method. We definitely want to verify all of the properties of the results, but do we really need to do this individually? The short answer is 'no.'`), React.createElement(MDXTag, {\n    name: \"h2\",\n    components: components\n  }, `Enter the Custom Matcher`), React.createElement(MDXTag, {\n    name: \"p\",\n    components: components\n  }, `A custom matcher is nestled in a `, React.createElement(\"code\", {\n    className: \"language-text\"\n  }, \"beforeEach\"), ` function. This will cause Jasmine to load the matcher prior to EVERY `, React.createElement(\"code\", {\n    className: \"language-text\"\n  }, \"describe\"), ` and `, React.createElement(\"code\", {\n    className: \"language-text\"\n  }, \"it\"), ` in your test suite.`), React.createElement(MDXTag, {\n    name: \"p\",\n    components: components\n  }, `Within the `, React.createElement(\"code\", {\n    className: \"language-text\"\n  }, \"beforeEach\"), ` is `, React.createElement(\"code\", {\n    className: \"language-text\"\n  }, \"this.addMatcher\"), ` that takes an `, React.createElement(\"code\", {\n    className: \"language-text\"\n  }, \"object\"), ` whose properties are your actual custom matchers. In our example the 'toEqualDate' matcher is the only property, but you can add as many as you might need for your application.`), React.createElement(MDXTag, {\n    name: \"p\",\n    components: components\n  }, `In the scope of the `, React.createElement(\"code\", {\n    className: \"language-text\"\n  }, \"toEqualDate\"), ` function, we pass in the `, React.createElement(\"code\", {\n    className: \"language-text\"\n  }, \"expectedDate\"), ` parameter. This is the argument passed into `, React.createElement(\"code\", {\n    className: \"language-text\"\n  }, \"toEqualDate(myExpectedDate)\"), `. We also have access to `, React.createElement(\"code\", {\n    className: \"language-text\"\n  }, \"this.actual\"), ` that is the argument passed into `, React.createElement(\"code\", {\n    className: \"language-text\"\n  }, \"expect(myActualDate)\"), ` within your test.`), React.createElement(MDXTag, {\n    name: \"p\",\n    components: components\n  }, `The next important bit is the `, React.createElement(\"code\", {\n    className: \"language-text\"\n  }, \"this.message\"), ` function that Jasmine will use to display any custom error messages. In this case we are returning two messages as appropriate. The first will return an invalid match, and the second will return a message if either object is not a valid date (if they are undefined, null, or incorrectly formatted).`), React.createElement(MDXTag, {\n    name: \"p\",\n    components: components\n  }, `Finally the `, React.createElement(\"code\", {\n    className: \"language-text\"\n  }, \"toEqualDate\"), ` function will return true or false based on the values we are comparing. If they are indeed valid `, React.createElement(\"code\", {\n    className: \"language-text\"\n  }, \"Date\"), ` objects, it will compare them. If they are not, we return false.`), React.createElement(MDXTag, {\n    name: \"p\",\n    components: components\n  }, `At the top of the `, React.createElement(\"code\", {\n    className: \"language-text\"\n  }, \"beforeEach\"), ` we also have two utility methods to clean up our custom matcher.`), React.createElement(MDXTag, {\n    name: \"h2\",\n    components: components\n  }, `Keeping it Clean and DRY`), React.createElement(MDXTag, {\n    name: \"p\",\n    components: components\n  }, `I don't know about you, but these tests look a `, React.createElement(MDXTag, {\n    name: \"strong\",\n    components: components,\n    parentName: \"p\"\n  }, `lot`), ` better to me. While the overall lines of code may have increased, we've created a reusable solution that can be used over and over again while not repeating ourselves. Our tests now have a single `, React.createElement(\"code\", {\n    className: \"language-text\"\n  }, \"expect\"), ` that is easy to understand and clearly expresses the intent of the test in an easy to read way.`), React.createElement(MDXTag, {\n    name: \"h2\",\n    components: components\n  }, `Additional Reading`), React.createElement(MDXTag, {\n    name: \"p\",\n    components: components\n  }, React.createElement(MDXTag, {\n    name: \"a\",\n    components: components,\n    parentName: \"p\",\n    props: {\n      \"href\": \"https://github.com/pivotal/jasmine/wiki/Matchers\"\n    }\n  }, `Official Documentation on Jasmine Matcher`)), React.createElement(MDXTag, {\n    name: \"p\",\n    components: components\n  }, React.createElement(MDXTag, {\n    name: \"a\",\n    components: components,\n    parentName: \"p\",\n    props: {\n      \"href\": \"http://lostechies.com/derickbailey/2011/09/03/custom-jasmine-matchers-for-clarity-in-testing-backbone-js-models/\"\n    }\n  }, `Custom Jasmine Matchers For Clarity In Testing Backbone.js Models`)), React.createElement(MDXTag, {\n    name: \"p\",\n    components: components\n  }, React.createElement(MDXTag, {\n    name: \"a\",\n    components: components,\n    parentName: \"p\",\n    props: {\n      \"href\": \"http://testdrivenwebsites.com/2010/08/04/custom-jquery-matchers-in-jasmine/\"\n    }\n  }, `Custom jQuery matchers in Jasmine`)));\n});"}}},"pageContext":{"id":"d5cd52a5-fb13-5663-85d7-f3d86eafbc9c","prev":{"id":"b3302bf6-e882-573d-b579-d5a2b3d370fd","parent":{"name":"2013-04-09-getting-to-know-vim","sourceInstanceName":"legacy"},"excerpt":"It's like coming full circle. When I was first introduced to computers, they very much resembled what I see in\nTerminal today. I've always had a distinct fondness for the command line\ninterface. That said, when I started using computers…","fields":{"title":"Getting to Know VIM","slug":"2013/04/09/Getting-to-Know-VIM","categories":[],"date":"2013-04-09 14:04"},"code":{"scope":"/Users/joel/Code/joelhooks-com/.cache/gatsby-mdx/remote-mdx-dir/3010b3badc54a9dfa4a4c80e419a41b2.js"}},"next":{"id":"bc6bf746-e108-55b5-a2cf-8c4e49b414e9","parent":{"name":"2012-08-28-practical-object-oriented-design-in-ruby-is-a-really-good-book","sourceInstanceName":"legacy"},"excerpt":"I've been reading the Rough Cut of  Practical Object Oriented Design , and I have been absolutely enjoying every page. It isn't very often that a technical book comes along that really strikes me as a \"new classic,\" but this one qualifies.  Sandi…","fields":{"title":"Practical Object Oriented Design is Excellent","slug":"2012/08/28/Practical-Object-Oriented-Design-is-Excellent","categories":[],"date":"2012-08-28 16:35"},"code":{"scope":"/Users/joel/Code/joelhooks-com/.cache/gatsby-mdx/remote-mdx-dir/3010b3badc54a9dfa4a4c80e419a41b2.js"}}}}